# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute log-density of multivariate normal distribution with mean zero
#' and covariance matrix Sigma at vector x
#' This function computes the log-density of a multivariate normal distribution
#' with mean zero and covariance matrix Sigma at point x.
#' @param x A vector representing the point at which to evaluate the density
#' @param Sigma A positive definite covariance matrix
#' @return The log-density value at point x
#' @examples
#' \dontrun{
#' x <- rnorm(5)  # 5-dimensional point
#' Sigma <- diag(5)  # Identity covariance matrix
#' log_density <- logdmvn_arma(x, Sigma)
#' }
logdmvn_arma <- function(x, Sigma) {
    .Call(`_CBKMR_logdmvn_arma`, x, Sigma)
}

#' Compute log-density of multivariate normal distribution with mean zero
#' and covariance matrix Sigma at vector x, returning also U = L^-1
#' This function computes the log-density of a multivariate normal distribution
#' with mean zero and covariance matrix Sigma at point x, and also returns
#' the matrix U = L^-1 where L is the lower triangular matrix from the Cholesky decomposition of Sigma.
#' @param x A vector representing the point at which to evaluate the density
#' @param Sigma A positive definite covariance matrix
#' @return A list containing the log-density value at point x and the matrix U
#' @examples
#' \dontrun{
#' x <- rnorm(5)  # 5-dimensional point
#' Sigma <- diag(5)  # Identity covariance matrix
#' result <- logdmvn_arma_with_U(x, Sigma)
#' log_density <- result$log_density
#' U <- result$Ut
#' }
logdmvn_arma_with_U <- function(x, Sigma) {
    .Call(`_CBKMR_logdmvn_arma_with_U`, x, Sigma)
}

#' Compute the log-density of a copula-based Bernoulli model without covariates
#' This function computes the log-density of a copula-based Bernoulli model
#' with only an intercept term (no covariates).
#' @param y A vector of binary response variables (0s and 1s)
#' @param beta0 The intercept parameter
#' @param Ut Either a matrix or a list containing the necessary components for the copula
#' @return The log-density value of the copula-based Bernoulli model
#' @examples
#' \dontrun{
#' y <- c(0, 1, 1, 0, 1)  # Binary response vector
#' beta0 <- 0.5  # Intercept
#' Ut <- matrix(...)  # Some matrix or list for copula, e.g., from NNGP by running build_AD_rcpp
#' log_density <- lCBpdf_bernoulli_no_X(y, beta0, Ut)
#' }
lCBpdf_bernoulli_no_X <- function(y, beta0, Ut) {
    .Call(`_CBKMR_lCBpdf_bernoulli_no_X`, y, beta0, Ut)
}

#' Build the A and D matrices for the NNGP model such that
#' Cov = (I - A)^T D (I - A)
#' @param coords An n x p matrix of coordinates
#' @param neighbor_matrix An n x
#' m integer matrix of neighbor indices (1-based, with NA for missing neighbors)
#' @param sigma2 The variance parameter for the Gaussian kernel
#' @param nugget_stabilizer A small value added to the diagonal for numerical stability
#' @return A list containing the sparse matrix triplet (A_i, A_j, A_x) for the sparse matrix A
#'  and the vector D
#'  @examples
#' \dontrun{
#' coords <- matrix(runif(100), nrow=20)  # 20 points in 5D
#' neighbor_matrix <- matrix(sample(c(1:20, NA), 60, replace=TRUE), nrow=20)  # 3 neighbors per point
#' sigma2 <- 1.0
#' result <- build_AD_rcpp(coords, neighbor_matrix, sigma2)
#' A_i <- result$A_i
#' A_j <- result$A_j
#' A_x <- result$A_x
#' D <- result$D
#' }
build_AD_rcpp <- function(coords, neighbor_matrix, sigma2, nugget_stabilizer = 1e-8) {
    .Call(`_CBKMR_build_AD_rcpp`, coords, neighbor_matrix, sigma2, nugget_stabilizer)
}

#' Compute the log-likelihood of the NNGP model with with tau as the shrinkage parameter
#' @param x An n-dimensional vector of observations
#' @param coords An n x p matrix of coordinates
#' @param w A p-dimensional row vector of weights for each dimension
#' @param tau The shrinkage parameter (between 0 and 1)
#' @param neighbor_matrix An n x m integer matrix of neighbor indices (1-based, with NA for missing neighbors)
#' @param nugget A small value added to the diagonal for numerical stability
#' @return The log-likelihood value
#' @examples
#' \dontrun{
#' x <- rnorm(20)  # 20 observations
#' coords <- matrix(runif(100), nrow=20)  # 20 points in 5D
#' w <- runif(5)  # weights for each dimension
#' tau <- 0.5
#' neighbor_matrix <- matrix(sample(c(1:20, NA), 60, replace=TRUE), nrow=20)  # 3 neighbors per point
#' loglik <- rnngp_loglik_tauonly(x, coords, w, tau, neighbor_matrix)
#' }
rnngp_loglik_tauonly <- function(x, coords, w, tau, neighbor_matrix, nugget = 1e-8) {
    .Call(`_CBKMR_rnngp_loglik_tauonly`, x, coords, w, tau, neighbor_matrix, nugget)
}

#' Same as rnngp_loglik_tauonly but also return Ut as a list such that U.ImA = I-A
#' and U.D_inv_sqrt = D^{-1/2}
rnngp_loglik_tauonly_use_AD <- function(x, coords, w, tau, neighbor_matrix, nugget = 1e-8) {
    .Call(`_CBKMR_rnngp_loglik_tauonly_use_AD`, x, coords, w, tau, neighbor_matrix, nugget)
}

#' Compute RBF kernel matrix with corresponding weights using OpenMP
#'
#' This function computes the RBF kernel matrix for a given data matrix Z
#' and a vector of weights w, utilizing OpenMP for parallelization.
#' @param Z An N x p matrix where each row is a data point.
#' @param w A vector of length p containing weights for each dimension.
#' @return An N x N RBF kernel matrix.
#' @examples
#' \dontrun{
#' Z <- matrix(rnorm(100), nrow=10)  # 10 data points in 10D
#' w <- runif(10)                    # weights for each dimension
#' K <- kernel_mat_RBF_rcpp_openmp(Z, w)
#' }
kernel_mat_RBF_rcpp_openmp <- function(Z, w) {
    .Call(`_CBKMR_kernel_mat_RBF_rcpp_openmp`, Z, w)
}

